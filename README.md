javaの基本をまとめる

```
●java  変数宣言につて
データ型 変数名;
int c;

●ローカル変数のスコープ
{から}までをブロックでブロック内で扱う変数がローカル変数のスコープと言う

●クラスにつて
クラスとは、プログラムを実行するための処理をまとめたモノで、クラスの処理の中にはメンバ変数や、処理を実行するためのメソッドが作成可能 
 クラス名の1文字目はunicode文字、$、_です。

実装を持たないメソッドの宣言のことを「抽象メソッド」と呼ぶ→抽象クラス

抽象メソッドの実装は、抽象クラスを継承したサブクラスが提供する。

具象クラスは、実行するためのクラスです。そのため、すべてのメソッドが実装済みでなくてはいけません。

● クラス定義方法

アクセス修飾子  class クラス名

 public class ClassHoge {

}

アクセス修飾子 データ型  変数名
public int number;

メソッド定義の外側で宣言すること

1. public 全てのクラスからアクセス可能

2. private 同一クラスからアクセス可能

3. protected 同一パッケージ内のクラスからと、サブクラスからアクセス可能

●クラスに定義できること

1 インスタンスの状態を表現するフィールド

2 インスタンスの事前準備のためのコンストラクタ

3 一連の処理をまとめたメソッド

● クラスのインスタンス化について
 インスタンス生成の構文

クラス名 変数名 = new クラス名(引数ありなし);

ClassSample cs = new ClassSample();

● クラスは**「型」の定義で、クラスをベースにインスタンスを生成して初めて利用ができ、インスタンスを生成することを 「インスタンス化」 と呼ぶ。

変数代入の注意点、インスタンスは別の領域（ヒープ）に作られるため、変数にはその領域にアクセスするためのリンク情報が代入される

● インスタンスのメソッド呼び出しについて

構文  変数名.メソッド名(引数);

public class Main  {

public static void main (String[] args) {

ClassA classA = new ClassA();

// メソッド呼び出し、変数名.メソッド名()

   classA. doMethod ();

    ｝

 ｝

class ClassA {

   void doMethod () { 処理など

  ｝

｝

● コンストラクタの定義について
メソッドの一つ、詳細↓

コンストラクタは、生成したインスタンスがほかのインスタンスから 使われる前に事前準備 をするためのメソッドです。

ルール

1 コンストラクタ名は、クラス名と同じでなければならない

2 戻り値型は記述できない

3 インスタンス生成時にしか使えない

【構文】

アクセス修飾子 コンストラクタ名（引数）｛

｝ 

【例題】

public class mainA {

    public static void main(String[] args) {

        インスタンスの生成、new演算子でコンストラクタを指定し、実行する↓

        クラス名 変数名 = new クラス名(引数1);    

    }

}

class B {

コンストラクタ↓（インスタンス生成時に実行される）

    public クラス名(引数1){

        処理など

    }

}


● this()はコンストラクタ内から他のコンストラクタを呼び出すために使われる、必ず最初の文として記述する必要あり。　super()も同じ

public class classB {

    private int a;

//引数なしコンストラクタ

    public classB() {

        this(10);  // オーバーロードしたコンストラクタ実行、コンストラクタの先頭で記述する

    }

    public classB(int a) {

        this.a = a;

    }

}

● 継承がされるクラスのコンストラクタ実行順序

public class B extends A {

 public B() //bクラスのコンストラクタ

　super(); →コンパイル時に追加される

System. out. println("B");

｝

コンパイルで追加されるコードはデフォルトコンストラクタです。

引き数なしでsuper();が呼び出すので、継承元と引数か一致している必要性があります。



● 配列宣言 について
型名[] 配列変数名;



型名 配列変数名[] = new 型名[要素数];

int foo[] = new int[3];

宣言と同時に配列を初期化する

int[] foo = {1, 2, 3, 4, 5};

.lengthで配列の要素数取得

static変数 クラスに属するフィールド、別名クラス変数、staticフィールド 

アクセス修飾子 static  型名 変数;
public static int num = 0;

● staticフィールドの宣言について

アクセス修飾子 static  型名 変数

public class classA {

    static String str; //staticフィールドの宣言、インスタンス生成なしで利用出来るフィールド

}

public class Sample {

public static void main(String[] args) {

ClassA c1 = new ClassA();

ClassA c2 = new ClassA() ;

ClassA. str = "hoge"；// staticフィールドの利用クラス名.フィールド名

c1. num = 7;

c2. num = 4;

  }

｝

 別の呼出し方法

インスタンスの変数名.staticメソッド名(引数)

ただし、public static int getNumber() { 

return number //staticメソッド内から別で宣言したインスタンスフィールドへアクセスさせることは出来ない

}

○　javaが使えるメモリ領域の内ヒープ領域に保存されるが、staticフィールドはstatic領域に保持される全てのインスタンスで共有されるのがstaticフィールドの特徴

インクリメントの動作
int y = x++;

→ y = 6, x = 7（後置なので、先に 6 を代入、あとで x を +1）

int z = ++y;

→ y = 7, z = 7（前置なので、先に y を +1、そして z に代入）

○　繰り返し処理
for (初期化; 条件; 更新) {

    // 繰り返し処理

}

○　論理演算子とif文
boolean and = (true && false); // AND

左の結果がfalseの場合は、右の結果true.falseいずれでも条件式の結果はfalseになるため、右は評価しない。
boolean or = (true || false); // OR

左の結果がtrueであれば、右は評価されない。

boolean not = !true; // NOT
ショートサーキット演算子、短絡演算子
if (condition) {

    // 条件が真の場合の処理

} else if (anotherCondition) {

    // 別の条件が真の場合の処理

} else {

    // どちらの条件も偽の場合の処理

}

○　switch文
switch (variable) {

    case 1:

        // 変数が1の場合の処理

        break;

    case 2:

        // 変数が2の場合の処理

        break;

    default:

        // それ以外の場合の処理

        break;

}

○　while文
while (condition、条件式は1つのみ) {

    // 条件が真の間繰り返す処理で、boolean戻す

}

○　do-while文
do {

    // 少なくとも1回は実行する処理、条件式省略不可

} while (条件式);

for文
for (int i = 0; i < 10; i++) {

      初期化     条件式    反復式

    // 10回繰り返される処理

}

【continue文】

 for文のブロック内でcontinueが実行されると以降の処理が実行されずに反復式に処理が移る
また、break;が実行されるとループを終了します。

○　拡張for文
for (変数宣言 : 式) {

          // int e : arrayなど、

}

例

    public static void main(String[] args) {

        int plusTotal = 0;

        int minusTotal = 0;

        int number[] = { 1, 2, 3, 4, 5 };

        for (int score : number) {

            // 配列内で足し算するループ

            plusTotal += score;

            // 配列内で引き算するループ

            minusTotal -= score;

        }

○　カプセル化
設計原則の一つ、どのような流れで処理するのか、どのようなデータを扱うのかなど

データの扱いから設計するのがオブジェクト指向設計手法の特徴です。

カプセル化は、関係するデータをまとめ、さらにそのデータを使う処理をまとめて、1つのモジュールとして定義することです。

データ隠蔽も含まれる、データ隠蔽を実現するにはフィールドのアクセス修飾子を private  にすることで、制御する。

○　アクセスメソッド
getterは値を取り出す、setterは値をフィールドにセットすること。

○　抽象化（abstraction アブストラクション）
抽象化は、注目すべき要素を抜き出し、それ以外を無視することによって、複雑な問題を単純化する方法  ↓

 抽象化してオブジェクトを扱うこと を「ポリモーフィズム」と呼ぶ

・抽象クラスについて

　クラスとinterface両方の性質を持つクラスです

抽象クラスはインスタンスできない

抽象クラスに定義したメソッドは抽象クラスを継承する具像クラスが実装する

抽象クラスに定義するメソッドはabstractで修飾しないとコンパイルエラーになる

○　継承について
  継承を使うには「extends」句を用いる

ポリモーフィズムは、使う側と使われる側が直接関係しないようにすることで、変更時の影響範囲を局所化させる。
// スーパークラス（親クラス）
public class Animal {

    public void eat() {

        System.out.println("This animal eats food.");

    }
}
// 派生クラス（子クラス）サブクラス 

    サブクラス         スーパークラス

public class Dog extends Animal {

    public void bark() {

        System.out.println("The dog barks.");

    }

}
// 使用例
public class Main {

    public static void main(String[] args) {

        Dog myDog = new Dog();

        myDog.eat();  // 親クラスのメソッド

        myDog.bark(); // 子クラスのメソッド

    }

}

○　情報隠蔽の概念
情報隠蔽は抽象化の効果を維持する ために必要な設計原則  です。

  ・javaでは、公開部分をインタフェースとして定義する、パッケージやアクセス修飾子を使用して制御する。

  ・コンストラクタを使ったアクセス制御は、アクセス修飾子にデフォルト、protected、privateなども使える

○　インタフェースについて
 クラスは型と実装の両方を持っている、実装がなく、(型だけ定義したもの)を インタフェース と言う。

型はオブジェクトの種類として考える。

 ・インタフェースはインスタンス化出来ない。

  実装がないとは具体的な動作や処理を持たないこと

 反対に 実装は実際に動作すること。

・インタフェースには、メソッドの宣言、staticな定数のみが定義出来る

・メソッドの宣言について

メソッドの宣言で波括弧{}を記述すると抽象メソッドではなく、具体的な処理を持つ具像メソッドとしてコ　ンパイラに解釈される

(暗黙的にpublic、abstractionで修飾される)

公開するために定義する

・インターフェースを実現する方法
クラスの宣言時にimplementsを使う

例 インターフェースの定義 多重継承可能,区切り

public interface Sample { 

 void sample();

}

インターフェースを実現したクラス

public class Sample2 implements Sample {

  public void sample {

 }

}
クラスには一度に複数のインターフェースを実現できる　implementsの後ろにカンマ区切りでinterfaceの名前を列挙する

○　has-a関係について
 ものごとを分解して全体と部分の関係で表現するのが、 has-a 関係です。
public class Car {

エンジン型のフィールド

private Engine engine;

public void setEngine (Engine engine) {

this. engine = engine;

｝
}
2行目のEngine型のフィールドによって、CarはEngineを持っていることを表現します。
is-a関係について
is-a関係は「サブクラス is-a スーパークラス」または「実装クラス is-a インタフェース」という関係で表現する、下位から上位への分類たいしてだけです。

○　オーバーロードについて
オーバーロードは多重定義です。

同名メソッドを複数定義できる。

シグニチャが異なること

シグニチャはメソッド名、引数の数、引数の型、引数の順番が含まれる。

・オーバーロードしたメソッドは引数に渡すデータの型と数、順番によりどれが実行されるかが決まります。

○　オーバーライドについて
継承された親クラスのメソッドを、子クラスで同じメソッド名、引数、戻り値で再定義し、処理内容を上書きすること

① メソッドのシグニチャがスーパークラスのものと同じこと

② 戻り値の型がスーパークラスのメソッドと同じか、サブクラスであること

③メソッドのアクセス制御がスーパークラスと同じか、それよりも緩いこと

○　オーバーライドしているメソッドのthrows節について

①オーバーライドしているメソッドのthrows節を持たなくても良い

②持つ場合はオーバーライドしている列挙されている例外の形が、スーパークラスのメソッドに例外と同じ型かそのサブタイプであること

○　throws節で複数の例外を宣言していた場合そのうちの一部だけをthrows節に残すことも可能

throwsの意味、そのメソッドが例外をスローする可能性があると宣言すること

スーパークラスに処理を追加したいだけ

super.メソッド名またはsuper.フィールド名

スーパークラスのインスタンスやフィールドにアクセス出来る。

this.キーワードについて
thisはインスタンスそのものまたは、自分のクラスのオブジェクトの変数の意味です。

【例題】
public class ClassHoge {

private int num;

public void setNum(int num) {

// 右辺が引数のnum、左辺が変数のnum

this.num = num

}

○　コンパイル後のクラスファイルを確認する
javap -c B コマンドで確認できる

-cはクラスのメソッドごとに、逆アセンブルされるコード(たとえば、Javaバイト・コードで構成される命令)を出力します。
また、継承される情報については、サブクラスにはどのスーパークラスを継承するかという指示だけが記述されることになる

○　型の互換性について
あるクラス型の変数を実現関係や継承関係にある上位の型に変換することを「アップキャスト」と呼びます。反対に、実現関係や継承関係にある下位の型に変換することを「ダウンキャスト」と呼びます

・上位の型に変換するアップキャストはコンパイラによって自動的に行われる

しかし、下位の型に変換するダウンキャストはプログラマーが明示的にキャスト式を記述できる

実際に動作するインスタンス型との互換性がなければ実行時に例外がスローされる
(データ型) 変数
packageについて
packageとは次の3つを提供するものです

1.名前空間の提供、名前の衝突を避ける

2.アクセス修飾子と組合せてアクセス制御機能を提供

3.クラスの分類を可能にする

ディレクトリ構造とマッピングされる
構文　　ソースファイルの先頭行で宣言
package パッケージ名;
import インポートするクラスの完全修飾クラス名;
java.langパッケージはimport宣言する必要なし
インポート宣言はpackage宣言の後ろから、クラス宣言の前までにインポート宣言をする
java.util.＊でワイルドカード表記も可能でパッケージ名を省略できる


```